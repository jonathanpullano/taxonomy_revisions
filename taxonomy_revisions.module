<?php

/**
 * Implementation of hook_menu
 */
function taxonomy_revisions_menu() {
  $menu['taxonomy/term/%term/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'taxonomy_revisions_revision_overview',
    'page arguments' => array(2),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2),
    'weight' => 2,
    'file' => 'taxonomy_revisions.pages.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['taxonomy/term/%term/revisions/%/view'] = array(
    'title' => 'Revisions',
    'page callback' => 'term_show_revision',
    'page arguments' => array(2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'view'),
    'type' => MENU_CALLBACK,
  );
  $items['taxonomy/term/%term/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_revision_revert_confirm', 2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'update'),
    'file' => 'node.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['taxonomy/term/%term/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_revision_delete_confirm', 2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'delete'),
    'file' => 'node.pages.inc',
    'type' => MENU_CALLBACK,
  );
}

/**
 * Implementation of hook_taxonomy
 * This is the hook where all the work gets done.
 *
 * NOTE: In Drupal 7, this is replaceced by several functions,
 * one for each op and type. For example: hook_taxonomy_term_load().
 *
 * The op has three possible values: delete, insert, and update.
 * The type can be: term, or vocabulary
 * The contents of the array vary based on what the type and op are,
 * but contain the information about the object being modified.
 **/
function taxonomy_revisions_taxonomy($op, $type, $array = NULL) {
  //Drupal convention normally dictates to use a switch statment here,
  //but this is very messy. This approach improves code readability.
  $function = "taxonomy_revisions_{$type}_{$op}";
  call_user_func($function, $array);
}

//@pullano: Ask what would core do?

function taxonomy_revisions_vocabulary_delete($vocabulary) {
  //TODO: Write me
}

function taxonomy_revisions_vocabulary_insert($form_values) {
  //TODO: Write me
}

function taxonomy_revisions_vocabulary_update($form_values) {
  //TODO: Write me
}

/**
 * When a term is deleted, delete its revisions
 */
function taxonomy_revisions_term_delete($term) {
  db_query('DELETE FROM {term_revisions} WHERE tid = %d', $term->tid);
}

function taxonomy_revisions_term_insert($form_values) {
  //TODO: Write me
}

/** 
 * On an update, we take the old value that was stored in the term_data
 * table and move it into the term_revisions table. Note that the taxonomy
 * module will still overwrite the current entry in the term_data table.
 * By allowing the term_data table to always keep the "current revision"
 * we guarentee that Drupal will always find the latest revision when
 * it looks up the term.
 */
function taxonomy_revisions_term_update($form_values) {
  $record = db_result(db_query('SELECT tid, vid, name, description, weight FROM {term_data} WHERE tid = "%d"'));
  //Note that tvid is not set, but drupal_write_record will increment auto_incrementing fields.
  drupal_write_record('term_revisions', $record);
}

/**
 * Implementation of hook_form_alter()
 */
function taxonomy_revisions_form_alter($form, $form_state, $form_id) {
  $term = menu_get_object('term');
  switch($form_id) {
    case "taxonomy_form_term":
    $form['revision_information'] = array(
      '#type' => 'fieldset',
      '#title' => 'Revision information',
      '#collapsible' => 'TRUE',
      '#collapsed' => $term->tvid,
      '#weight' => 1,
      'revision' => array(
        '#type' => 'checkbox',
        '#title' => 'Create new revision',
        '#default_value' => 'FALSE',
      ),
      'log' => array(
        '#type' => 'textarea',
        '#title' => 'Log message',
        '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.'),
        '#rows' => 2,
      ),
    );
    //@pullano is this a good idea?
    //This is the result of a deficiency in drupal
    $form['identification']['#weight'] = 0;
    $form['advanced']['#weight'] = 2;
    $form['submit']['#weight'] = 3;
    $form['delete']['#weight'] = 3;
    break;
  }
}

/**
 * API Function: get the vid of the newest revision associated with the term
 * @param mixed The term to look up
 * @result mixed The tvid of the term being fetched, or FALSE on an error
 */
function _taxonomy_revisions_get_term_revision($term) {
  //It is often useful to provide the user of an API function with many ways to call it.
  //Here we require a term to fetch the tid, but the user of the function can provide the
  //term in many different ways
  if (is_array($term)) {
    $tid = $term['tid'];
  } elseif (is_object($term)) {
    $tid = $term->tid;
  } elseif (is_string($term)) {
    //Note that the Drupal may have multiple terms with the same name!
    $taxonomy_term = taxonomy_get_term_by_name($term); 
    if (count($taxonomy_term) != 1) {
      return FALSE;
    }
    $tid = $taxonomy_term[0]->tid;
  } elseif (is_numeric($term)) {
    $tid = $term;
  }
  //Something has gone horribly wrong, let's bail!
  if (!is_numeric($tid)) {
    return FALSE;
  }
  
  $term = taxonomy_get_term($tid);
  $term->tvid = 0;
  return $term;
}

/**
 * API Function: Get a particular revision of a taxonomy term
 */
function _taxonomy_revisions_get_revision($tvid, $tid = 0) {
  if ($tvid) {
    $query = <<<EOF
      SELECT tid, tvid, vid, name, description, weight 
      FROM {term_revisions} 
      WHERE tvid = "%d"
EOF;
  } elseif(!$tid) {
    //If you want to look up a tvid = 0, you must provide a tid
    return FALSE;
  }
  return db_result(db_query($query, $tvid));
}

/**
 * Return a list of all the existing revision numbers.
 * @see node_revision_list
 */
function term_revision_list($term) {
  $revisions = array();
  $query_string = <<<EOF
    SELECT tid, tvid, vid, name, description, weight 
    FROM {term_revisions} 
    WHERE tid = "%d" 
    UNION 
    SELECT tid, 0 as tvid, vid, name, description, weight
    FROM {term_data}
    WHERE tid = "%d"
EOF;
  $result = db_query($query_string, $term->tid);
  while ($revision = db_fetch_object($result)) {
    $revisions[$revision->tvid] = $revision;
  }
  return $revisions;
}

function _term_revision_access($term) {
  static $access = array();
  if (!isset($access[$term->tid])) {
    $term_current_revision = _taxonomy_revisions_get_term_revision(0,$term->tid);
    $is_current_revision = $node_current_revision->vid == $node->vid;
    // There should be at least two revisions. If the vid of the given node
    // and the vid of the current revision differs, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's
    // not good.
    if ($is_current_revision && (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node->nid)) == 1 || $op == 'update' || $op == 'delete')) {
      $access[$node->vid] = FALSE;
    }
    elseif (user_access('administer nodes')) {
      $access[$node->vid] = TRUE;
    }
    else {
      $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');
      // First check the user permission, second check the access to the
      // current revision and finally, if the node passed in is not the current
      // revision then access to that, too.
      $access[$node->vid] = isset($map[$op]) && user_access($map[$op]) && node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));
    }
  }
  return $access[$node->vid];
}
