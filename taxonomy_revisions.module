<?php

/**
 * Implementation of hook_menu
 */
function taxonomy_revisions_menu() {
  $items['taxonomy/term/%/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => '0'
  );
  $items['taxonomy/term/%/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'taxonomy_revisions_revision_overview',
    'page arguments' => array(2),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'view'),
    'weight' => 2,
    'file' => 'taxonomy_revisions.pages.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['taxonomy/term/%/revisions/%/view'] = array(
    'title' => 'Revisions',
    'page callback' => 'term_show_revision',
    'page arguments' => array(2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'view', 4),
    'type' => MENU_CALLBACK,
  );
  $items['taxonomy/term/%/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_revision_revert_confirm', 2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'update', 4),
    'file' => 'taxonomy_revisions.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['taxonomy/term/%/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_revision_delete_confirm', 2, 4),
    'access callback' => '_term_revision_access',
    'access arguments' => array(2, 'delete', 4),
    'file' => 'taxonomy_revisions.pages.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

function taxonomy_revisions_menu_alter(&$items) {
  //@todo fixme
  if (true) { //variable_get('taxonomy_revisions_enable_edit_link', 1)) {
    $items['taxonomy/term/%/edit'] = array(
      'title' => 'Edit',
      'page arguments' => array(2),
      'page callback' => 'taxonomy_admin_term_edit',
      'access arguments' => array('administer taxonomy'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'taxonomy.admin.inc',
      'file path' => 'modules/taxonomy',
      'weight' => '5',
    );
  }
  return $items;
}

/**
 * Implementation of hook_taxonomy
 * This is the hook where all the work gets done.
 *
 * NOTE: In Drupal 7, this is replaceced by several functions,
 * one for each op and type. For example: hook_taxonomy_term_load().
 *
 * The op has three possible values: delete, insert, and update.
 * The type can be: term, or vocabulary
 * The contents of the array vary based on what the type and op are,
 * but contain the information about the object being modified.
 **/
function taxonomy_revisions_taxonomy($op, $type, $array = NULL) {
  switch ($type) {
    case 'term':
      if ($op == 'delete') {
        db_query('DELETE FROM {term_revisions} WHERE tid = %d', $array->tid);
      } else if ($op == 'insert') {
        $record = array(
          'tid' => $array['tid'],
          'timestamp' => time(),
        );
        drupal_write_record('term_current_revision', $record);
      }
      break;

    case 'vocabulary':
      if ($op == 'delete') {
        //Write me!
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter()
 */
function taxonomy_revisions_form_alter($form, $form_state, $form_id) {
  $term = menu_get_object('term');
  switch($form_id) {
    case "taxonomy_form_term":
      if ($form_state['clicked_button']['#value'] != t('Delete')) {
        $form['revision_information'] = array(
          '#type' => 'fieldset',
          '#title' => 'Revision information',
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          '#weight' => 1,
          'revision' => array(
            '#type' => 'checkbox',
            '#title' => 'Create new revision',
          ),
          'log' => array(
            '#type' => 'textarea',
            '#title' => 'Log message',
            '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.'),
            '#rows' => 2,
          ),
        );
        //The default form submit handler will save over the term_data table, but we need that data first!
        //Therefore, our submit handler must come first
        $form['#submit'] = array_merge(array('taxonomy_revisions_taxonomy_form_term_submit'), $form['#submit']);

        //@pullano is this a good idea?
        //This is the result of a deficiency in drupal
        $form['identification']['#weight'] = 0;
        $form['advanced']['#weight'] = 2;
        $form['submit']['#weight'] = 3;
        $form['delete']['#weight'] = 4;
      }
      break;
  }
}

/** 
 * On an update, we take the old value that was stored in the term_data
 * table and move it into the term_revisions table. Note that the taxonomy
 * module will still overwrite the current entry in the term_data table.
 * By allowing the term_data table to always keep the "current revision"
 * we guarentee that Drupal will always find the latest revision when
 * it looks up the term.
 */
function taxonomy_revisions_taxonomy_form_term_submit($form, &$form_state) {
  //If a term already exists, the new revision box is checked and we are not on the delete form
  if ($form['#term']['tid'] && $form_state['values']['revision'] && $form_state['clicked_button']['#id'] == 'edit-submit') {
    $tid = $form['#term']['tid']; 

    $query = <<<EOF
      SELECT td.tid, vid, name, description, weight, tvid, log, timestamp
      FROM {term_data} td INNER JOIN {term_current_revision} tcr
      ON td.tid = tcr.tid
      WHERE td.tid = "%d"
EOF;

    $term_revision = db_fetch_object(db_query($query, $tid));
    if ($term_revision) {
      drupal_write_record('term_revisions', $term_revision);
    }


    //Note that tvid is not set, but drupal_write_record will increment auto_incrementing fields.
    $term_current_revision->log = $form_state['values']['log'];
    $term_current_revision->tid = $tid;
    $term_current_revision->timestamp = time();
    db_query('DELETE FROM term_current_revision WHERE tid = "%d"', $tid);
    drupal_write_record('term_current_revision', $term_current_revision);
  }
}

/**
 * API Function: get the vid of the newest revision associated with the term
 * @param $tid The term to look up
 * @param $reset Whether to reset the internal cache
 * @result mixed The tvid of the term being fetched, or FALSE on an error
 */
function _taxonomy_revisions_get_current_tvid($tid, $reset = FALSE) {
  //@todo make note of new caching mechanism in D7
  static $term_revisions = array();

  if ($reset) {
    $term_revisions = array();
  }

  if (!isset($terms[$tid])) {
    $term_revisions[$tid] = db_result(db_query('SELECT tvid FROM {term_current_revision} WHERE tid = %d', $tid));
  }

  return $term_revisions[$tid];
}

/**
 * API Function: Get a particular revision of a taxonomy term
 */
function _taxonomy_revisions_get_term_revision($tvid, $reset = FALSE) {
  static $term_revisions = array();

  if ($reset) {
    $term_revisions = array();
  }

  if (!isset($terms[$tvid])) {
    $query = <<<EOF
      SELECT td.tid, tvid, vid, name, description, weight, log, timestamp
      FROM {term_data} td INNER JOIN {term_current_revision} tcr
      WHERE tcr.tvid = "%d"
EOF;

    if ($record = db_fetch_object(db_query($query, $tvid))) {
      $term_revisions[$tvid] = $record; 
      return $record;
    }
    $query = <<<EOF
      SELECT tid, tvid, vid, name, description, weight, log, timestamp 
      FROM {term_revisions}
      WHERE tvid = "%d"
EOF;
    $term_revisions[$tvid] = db_fetch_object(db_query($query, $tvid));
  }
  return $term_revisions[$tvid];
}

/**
 * Return a list of all the existing revision numbers.
 * @see node_revision_list
 */
function term_revision_list($term) {
  $revisions = array();
  $query_string = <<<EOF
    SELECT tid, tvid, vid, name, description, weight, log, timestamp 
    FROM {term_revisions} 
    WHERE tid = "%d" 
    UNION 
    SELECT td.tid, tvid, vid, name, description, weight, log, timestamp
    FROM {term_data} td INNER JOIN {term_current_revision} tcr
    WHERE td.tid = "%d"
EOF;
  $result = db_query($query_string, $term->tid, $term->tid);
  while ($revision = db_fetch_object($result)) {
    $revisions[$revision->tvid] = $revision;
  }
  return $revisions;
}

/**
 * Access callback for term revision pages
 */
function _term_revision_access($tid, $op, $tvid = 0) {
  if (!$tvid) {
    $tvid = _taxonomy_revisions_get_current_tvid($tid);
  }
  static $access = array();
  if (!isset($access[$tid . ',' . $tvid])) {
    $term_current_revision = _taxonomy_revisions_get_term_revision($tvid);
    $is_current_revision = $term_current_revision->tvid == $tvid;

    // There should be at least two revisions. If the vid of the given term 
    // and the vid of the current revision differs, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's
    // not good.
    if ($is_current_revision && (db_result(db_query('SELECT COUNT(vid) FROM {term_revisions} WHERE tid = %d', $tid)) == 0 || $op == 'update' || $op == 'delete')) {
      $access[$tid . ',' . $tvid] = FALSE;
    }
    elseif (user_access('administer taxonomy')) {
      $access[$tid . ',' . $tvid] = TRUE;
    }
    else {
      //@todo: Do we want seperate permissions for revising terms and nodes? Ya!
      
      //Check if the user has permission to perform this specific op
      $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');
      $access[$tid . ',' . $tvid] = isset($map[$op]) && user_access($map[$op]);
    }
  }
  return $access[$tid . ',' . $tvid];
}
